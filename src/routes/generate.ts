import { Hono } from "hono";
import { createFalClient } from "@fal-ai/client";
import type { Image } from "@fal-ai/client/endpoints";
import type { App } from "../types";
import { generateSchema } from "../schemas";

const DEFAULT_MODEL = "fal-ai/flux/schnell";

// ---------------------------------------------------------------------------
// Prompt enhancement — makes the AI output wallpaper-ready images
// ---------------------------------------------------------------------------

function buildWallpaperPrompt(
  userPrompt: string,
  width: number,
  height: number,
): string {
  const ratio = width / height;

  // Determine orientation-specific composition hints
  let compositionHint: string;
  if (ratio >= 1.7) {
    // Ultra-wide / wide desktop (16:9, 21:9)
    compositionHint =
      "wide panoramic composition, expansive scene that fills the entire frame horizontally";
  } else if (ratio > 1) {
    // Standard landscape desktop (4:3, 3:2)
    compositionHint =
      "landscape composition, scene extends across the full width of the frame";
  } else if (ratio < 0.65) {
    // Tall phone screens (9:19.5, 9:21)
    compositionHint =
      "tall vertical composition, scene extends from top to bottom with layered depth";
  } else {
    // Near-square or moderate portrait
    compositionHint =
      "balanced composition, scene fills the frame evenly in all directions";
  }

  return [
    userPrompt,
    `Render as a beautiful wallpaper background: ${compositionHint}.`,
    "Smooth, uncluttered areas with no text, watermarks, or UI elements.",
    "Visually rich but not busy — suitable as a device wallpaper with icons on top.",
    "High detail, vivid colors, professional quality digital art.",
  ].join(". ");
}

const WALLPAPER_NEGATIVE_PROMPT = [
  "text",
  "watermark",
  "signature",
  "logo",
  "border",
  "frame",
  "letterbox",
  "pillarbox",
  "caption",
  "subtitle",
  "UI elements",
  "blurry",
  "low quality",
  "cropped",
].join(", ");

// ---------------------------------------------------------------------------

const generate = new Hono<App>();

generate.post("/", async (c) => {
  // Parse JSON body
  const body = await c.req.json().catch(() => null);
  if (!body) {
    return c.json({ error: "Invalid or missing JSON body" }, 400);
  }

  // Validate
  const parsed = generateSchema.safeParse(body);
  if (!parsed.success) {
    return c.json(
      {
        error: "Validation failed",
        details: parsed.error.issues.map((issue) => ({
          field: issue.path.join("."),
          message: issue.message,
        })),
      },
      400,
    );
  }

  const {
    prompt,
    width,
    height,
    model,
    negative_prompt,
    num_inference_steps,
  } = parsed.data;

  const selectedModel = model ?? DEFAULT_MODEL;

  // Enhance the prompt for wallpaper-quality output
  const enhancedPrompt = buildWallpaperPrompt(prompt, width, height);

  // Merge user's negative prompt with our wallpaper defaults
  const fullNegativePrompt = negative_prompt
    ? `${negative_prompt}, ${WALLPAPER_NEGATIVE_PROMPT}`
    : WALLPAPER_NEGATIVE_PROMPT;

  // Build fal.ai client with the user's API key
  const fal = createFalClient({ credentials: c.get("falKey") });
  const logger = c.get("logger");

  const falInput = {
    prompt: enhancedPrompt,
    image_size: { width, height },
    negative_prompt: fullNegativePrompt,
    ...(num_inference_steps ? { num_inference_steps } : {}),
  };

  logger.info(
    { model: selectedModel, ...falInput },
    "fal_subscribe_request",
  );

  const falStart = Date.now();

  try {
    const result = await fal.subscribe(selectedModel, {
      input: falInput,
    });

    const elapsed = Date.now() - falStart;
    const data = result.data as { images?: Image[] };

    if (!data.images || data.images.length === 0) {
      logger.warn({ model: selectedModel, elapsed }, "fal_subscribe_no_images");
      return c.json(
        { error: "No image was generated by the model" },
        500,
      );
    }

    const image = data.images[0];
    logger.info(
      { model: selectedModel, elapsed, imageUrl: image.url },
      "fal_subscribe_complete",
    );

    // Fetch the generated image binary from fal's CDN
    const imageResponse = await fetch(image.url);
    if (!imageResponse.ok) {
      return c.json(
        { error: "Failed to fetch the generated image from CDN" },
        502,
      );
    }

    // Stream the image back as a binary response
    return new Response(imageResponse.body, {
      headers: {
        "Content-Type":
          image.content_type ||
          imageResponse.headers.get("Content-Type") ||
          "image/png",
        "Content-Disposition": "inline",
        "Cache-Control": "public, max-age=86400",
      },
    });
  } catch (err) {
    const elapsed = Date.now() - falStart;
    logger.error({ err, model: selectedModel, elapsed }, "fal_subscribe_error");

    const message =
      err instanceof Error ? err.message : "Image generation failed";
    const status =
      typeof (err as Record<string, unknown>)?.status === "number"
        ? ((err as Record<string, unknown>).status as number)
        : 500;

    return c.json(
      {
        error: "Generation failed",
        message,
      },
      status >= 400 && status < 600 ? (status as 500) : 500,
    );
  }
});

export default generate;
